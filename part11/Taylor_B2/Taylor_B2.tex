
\resetcounters

\bibliographystyle{asp2010}

\markboth{Fitzpatrick et al.}{Application Interoperability with SAMP}

\title{Application Interoperability with SAMP}
\author{M.~Fitzpatrick,$^1$ O.~Laurino,$^2$ L.~Paioro,$^3$ and M.~B.~Taylor$^4$
\affil{$^1$National Optical Astronomy Observatory, Tucson AZ, U.S.A.}
\affil{$^2$Harvard-Smithsonian Center for Astrophysics, 60 Garden Street,
           Cambridge, MA 02138, U.S.A.}
\affil{$^3$National Institute for Astrophysics, IASF, Milano, Italy}
\affil{$^4$H.~H.~Wills Physics Laboratory, University of Bristol, U.K.}}

\aindex{Fitzpatrick, M.}
\aindex{Laurino, O.}
\aindex{Paioro, L.}
\aindex{Taylor, M. B.}


\begin{abstract}
The Simple Applications Messaging Protocol (SAMP) is a Virtual Observatory (VO) specification that enables astronomy software tools to exchange control information and data, allowing desktop applications to work as an integrated suite of tools rather than requiring complex functionality to be (redundantly) built into tools individually. In addition, SAMP allows new workflows to be created for the science user that leverages the advantages of each tool (e.g.\ visualization of tables or images, analysis, etc.), greatly reducing the time needed to switch between applications and tasks. We present here a short introduction to the protocol itself, a survey of some toolkits for application authors who wish to introduce SAMP functionality into their tools, and some examples of real-world usage. \end{abstract}

\section{Introduction}

The Simple Applications Messaging Protocol provides platform-independent messaging between tools based either on the desktop or the browser. The messaging architecture is based on a free-standing {\em hub\/} process that provides message brokering to external clients, providing the illusion of direct client-client interaction with the convenience of a single communication point. Messaging is built around the publish/subscribe model in which each client flags those message types (MTypes in the SAMP terminology), if any, it is willing to receive. SAMP is defined by the SAMP standard \citep{samp1.3}, and the design principles are discussed further in \citet{taylor2011}.

Section~\ref{sec:B2_libs} below lists a number of language-specific libraries and toolkits available that can help developers to work with SAMP and incorporate SAMP usage into their applications. Section~\ref{sec:B2_usage} gives some diverse examples of how these tools can be used to deliver improved science workflows.

\section{Toolkits and Implementations}
\label{sec:B2_libs}

A number of toolkits and libraries for use with SAMP are listed at \url{http://www.ivoa.net/samp}; this section describes some of them.

\subsection{JSAMP}

JSAMP is a hub implementation, toolkit, and client library written in Java. As well as a basic interface to the SAMP Hub and Client APIs, JSAMP provides easy-to-use GUI components for integrating SAMP use into interactive Java applications. JSAMP also incorporates a number of diagnostic tools, including extensive message logging capabilities and a graphical hub view that shows the details of currently registered clients and recently transmitted messages.

\subsection{SAMPy}

SAMPy is a Python toolkit and hub implementation. SAMPy will be part of  astropy \citep{O30_adassxxii}. Astropy is a common effort to develop a single Python core package for astronomy, involving about 100 developers from around the world, and is available from PyPI\footnote{\url{http://pypi.python.org/pypi/sampy/}}.

To start SAMPy's hub implementation it is sufficient to start the sampy executable, installed with the main distribution. As with other libraries, registering a client requires the instantiation of the client itself, its connection to the hub, and the binding of a Python function to specific MTypes. The function is used as a callback when a message with a bound MType is sent to the client. SAMPy also offers means to discover clients connected to the hub and send messages to them.

\subsection{Libsamp}

Libsamp is a library within the {\em VOClient\/} package (in development) that provides a C-language interface to enable applications to send and receive SAMP messages.  The API is designed to simplify and hide the details of the SAMP protocol from the application writer, providing standard methods to initialize the interface, declare metadata, post message callbacks, send specific message MTypes, and startup/shutdown messaging. Details of the hub discovery and registration, as well as handling of specific messaging patterns, are handled internally and are also fully accessible through low-level procedures.  These low-level procedures similarly allow application developers fine-grained control over the formatting of outgoing messages or parsing of return values.  Because the interface is implemented in C, bindings for many other languages can be easily generated automatically using SWIG,\footnote{\url{http://www.swig.org/}} or custom interfaces can be hand-generated to provide a more language-specific interface (e.g.,\ one that uses idioms of the language as in a {\em Pythonic\/} interface, or a binding for languages not supported by SWIG such as {\em SPP\/} used in IRAF\ooindex{IRAF, ascl:9911.002}).

\subsection{sampjs}

Sampjs is a small JavaScript library for use by browser-based applications that performs SAMP messaging using the Web Profile. Sampjs makes it easy to add SAMP messaging capabilities to web pages by adding a few lines of JavaScript, as well as allowing the possibility of fully SAMP-integrated web applications.

\section{Usage Examples}
\label{sec:B2_usage}

\subsection{Integration of GUI Tools}

A common usage scenario for SAMP is integrated use of multiple interactive desktop applications specialised for different data types. SAMP's data exchange enables them to work together as a single integrated suite with the union of the capabilities of the component tools. An example workflow involving TOPCAT\ooindex{TOPCAT, ascl:1101.010} (a table analysis tool) and Aladin\ooindex{Aladin, ascl:1112.019} (a sky image analysis tool) might be: 

1.\ display an image of a region of sky in Aladin\ooindex{Aladin, ascl:1112.019} 

2.\ acquire a catalogue in Aladin\ooindex{Aladin, ascl:1112.019} with multi-band photometry corresponding to sources visible in the region

3.\ overplot the catalogue positions on the sky imagery

4.\ send the catalogue to TOPCAT\ooindex{TOPCAT, ascl:1101.010} using SAMP

5.\ plot a color-magnitude diagram in TOPCAT\ooindex{TOPCAT, ascl:1101.010}

6.\ identify a sub-population in TOPCAT\ooindex{TOPCAT, ascl:1101.010} from the color-magnitude plot

7.\ send the sub-population referencing the original catalogue back to Aladin\ooindex{Aladin, ascl:1112.019} using SAMP

8.\ Aladin\ooindex{Aladin, ascl:1112.019} displays the sub-population sources in a way which distinguishes them visually from the others

The SAMP send operations are typically initiated by the user simply hitting an appropriate ``Send'' button in the GUI. The loose semantics of the messages typically exchanged by SAMP applications mean that this workflow could work in just the same way if different image- and/or table-analysis tools were used.

\subsection{SAMP as a Lightweight Remote Procedure Call Protocol}

Some projects have used SAMP as a lightweight protocol for remote procedure calls. The advantage of this approach is that robust off the shelf SAMP libraries can be used to build a thin layer on top of existing applications in different programming languages in order to make them communicate. Such a private interface can also be exercised by different clients than those that were targeted originally.

Iris\ooindex{Iris, ascl:1205.007} \citep{2012ASPC..461..893D}, the Virtual Astronomical Observatory tool for the analysis of Spectral Energy Distributions, for example, employed SAMP to make the connection between a Java application for spectral analysis \citep[Specview\ooindex{Specview, ascl:1210.016}, by STScI,][]{2000ASPC..216...79B} and a Python fitting engine \citep[Sherpa\ooindex{Sherpa, ascl:1107.005}, by SAO,][]{2007ASPC..376..543D}. The design is straightforward and requires the specification of methods, identified by MTypes; arguments, in the form of SAMP dictionaries; and exceptions, serialized as SAMP messages and as such propagated from one programming language to the other.

While Python offers natural means for deserializing dictionaries in the form of instances, a specific library was developed in Java for (de)serializing Java interfaces as SAMP messages. This makes the implementation of a simple inter-language remote API very straightforward and lightweight.

\subsection{SAMP from the Command Line}

The Libsamp library was used to fully SAMP-enable the IRAF\ooindex{IRAF, ascl:9911.002} Command Language (CL) as well as to build a command-line tool (called {\em vosamp\/}) to allow scripts to send (and optionally receive) messages.  In both cases, a simplified command interface further hides the details of the SAMP protocol from the user.  For example, a {\em load\/} command takes as a single argument the name of a local file or a URL. The IRAF\ooindex{IRAF, ascl:9911.002} CL or {\em vosamp\/} task determine whether this file is a FITS image or a VOTable and format the appropriate message type or supply additional arguments as needed. Options exist to send directed messages to specific applications or send messages using a particular message pattern.

For the {\em vosamp\/} command-line tool, the overhead of connecting to the Hub with each command in scripts is avoided by having the task run in the background as a persistent proxy.  On the first invocation the task registers with the Hub and then forks itself to run in the background while remaining connected to the messaging session.  Subsequent commands from the terminal or script are sent to this background proxy via IPC for execution, allowing a script to process many commands using a single application registration.  This capability means that any scripting language (e.g.\ Python, Perl, IDL, Bourne or C-shell, etc.) that can execute a host command can send SAMP messages without requiring detailed knowledge of the protocol by the script writer.  In cases where tighter integration with the language is required, bindings can be generated as needed.

\subsection{SAMP from Archive Query Web Pages}

Many data centers provide web-based access to their data holdings along the lines of a form which a user fills in, resulting in a web page listing one or more data products such as images, spectra, or catalogues, with the expectation that users will download these files to disk and then load them into a suitable viewer application.

Using the Web Profile introduced in SAMP 1.3 and a JavaScript library like sampjs, it is very easy (10--20 lines of JavaScript) to associate a button with each such link that sends the relevant file (in fact, its URL) directly to whatever suitable SAMP-aware viewer the user happens to be running, if any. It is straightforward to arrange for such buttons to be hidden in the absence of a SAMP hub, so non-SAMP-aware users do not experience unavailable functionality as increased clutter.

\bibliography{editor}
